Swift에서 크래시를 안나게 하는 네가지 습관

- 옵셔널을 옵셔널 답게
    - 먼저 바로 ! 강제 옵셔널 옵셔널을 잘쓰면 문제없다. 하지만 불편한경우가 있다 그런경우 !을 쓰게된다. as!, try!, IBOutlet ~~ UILabel!, 언랩에 관련된 !는 코드에서 존재하지 않아야한다. 50% 이상으 크래쉬가 거기서 나타난다. 묵시적언랩 일경우에는 내부적으로 옵셔널이 아닌걸로 가정하고 하고있지만 보장할순없다.  IUO(옵셔널 묵시적 추출) 강제추출과 같다.
    
    ```swift
    var num: Int! = 4   타입에 ! 를 붙힌것이 IUO다 .. 그냥 강제추출...
    ```
    
    코드에서는 !를 완전히제거 해달라 이렇게하면 크래쉬가 50%는 없어진다.
    
    부정을 의미하는 연산자 낫연산자는 제외
    
    어레이에서 인덱스를 접근할때 어레이의 카운트를 바운즈를 체크하지않으면 100% 크래쉬
    
    인덱스 유효한 바운즈 안에 있는지 확인해야한다. 배열의 인덱스값을 잘 체크해야한다.
    
    - 오버 플로우 크래쉬
        - 인트32,64 에서? 64에서는 멀쩡히 작동하는것이 32에서는 크래쉬가 난다.  인트 32의 범위가 벗어나기 때문에 인트라는 것들 숫자 저장? 숫자 연산시에 인트32,64 범위를 벗어나는지 확인
        - 역시 어레이 바운즈 확인.
        - 인트64타입을 만들때 생각보다 많이만듬 그리고 값이 크다  특정아이디가 정수인데 값이크다 실제로 클라이언트에서 들어와서 인트로 만들어져서 값을 넣다가 크래쉬가 난다
        - 이것들은 swift의 언어때문에 발생하는 크래쉬 이다
    - 오브젝티브씨 관계 크래쉬
        - 옵젝씨같은경우 룰러블?언블러블? 지정해주지 않으면 포스트 언랩된거처럼 보인다.
        - 하지만 옵젝씨가 닐을 오픈하는경우가 많다 이런경우 크래쉬가 난다. (댓글도움: nullability 이라는것을 명시해줘야 크래쉬를 필할수있다.) 이경우가 생각보다 빈번하게 발생한다.
        - 옵젝씨 내부코드에서  인셉션를 발생시킨경우 그를 사용하는 스위프트에서는 방법이 없다
            - 이건 에러 핸들링을 할수도없다.
    
    크래쉬는 반드시 잡아야하는 부분이다. 
    
    크래쉬 낮추는방법
    
    1. force unwap(강제추출) 하지말것, IUO도 하지말것 아이비아울렛도 ?로 변경해라 
    2. array를 쓸때 bound check를 꼭 하자
    3. 오버플로우를 주의해라. 인트32,64 범위 확인 하기 여기부분은 바로 죽기때문에 절대안된다 에러 핸들링조차 안됨.
    4. Objective-C와 엮인 부분에 주의해라 nullability체크 필히해야한다. 하지않으면 죽는경우가 난다.
        1. 옵젝씨에서 발생한 리셉션은 거기서 잡아서 핸들링하는 별도의 함수를 만들어야한다.
        
        ---


### 재귀 호출 할때 스택오버플로우 걱정하지 않는다.

Tail Call (함수의 끝에서 함수를 호출 하는 것)

함수가장 마지막에서 자기자신을 호출하거나 다른 함수를 호출

함수를 호출하는거말고는 하는게없다? 이럼뭐 필요없는거 아니야?

Tail Recursive (함수의 끝에서 자기 자신을 재귀호출 하는 것)

Tail Call Optiomization (함수의 끝에서 함수를 호출 하는 경우에 대한 최적화)

재귀를 잘 구현하면 코드가 깔끔해진다??

대신 스택을 많이쓰고 부하가 많이 걸린다. 그래서 재귀를 위험하다고 생각한다.

음…… 그냥 확인하다가 끝나는느낌???

결국 재귀를 쓸때 함수끼리 해버리니 더 잘된다?? 함수를 계속부르지말고 그 함수를 만들어서 연결시켜 쓰는게 좋다?

---

Value Type은 항상 stack에 저장된다고오????? 동작원리를 보여준다고하는군요.

```swift
func test() {
var ref1 = Reference(member1: 4, member2: 7)
var ref2 = ref1
var val1 = Value(member1: 10, member2: 11)
var val2 = val1
print(Unmanaged.paaUnretained(ref1).toOpaque()) 주소값 확인 프린트

withUnsafePointer(to: &ref1) {
print("re1 address = \($0)")  메모리 주소값 나옴
}
}
```

LLDB창에서 오른쪽 해서  View Menory of “va1”  눌러서 메모리 숫자 확인하기

벨류 타입은 0a 0b 등 깔끔하다(스택) 근데 레퍼런스(클래스) 타입은 뭔가 이것저것 숫자가 많다 뒤에 쓰는 숫자가 나오기도 한다 

레퍼런스 타입속에 벨류값을 생성했을때 클래스 안에 프로퍼티로 구조체 생성해봄

→ 구조체 힙에 저장된다… 허허

---

옵셔널과 불이 만났을때 optional, Bool 

기본 불값을 만들어서 이프문으로 확인한다.

참과거짓으로 이프문에서 작동되는 프린트문 확인

당연 선언한곳에서 이프문 발생

하지만 다음 이프문 시작전 불값을 닐로 변경한다면 

옵셔널로 변경되었다 그렇기에 참과 거짓이 아닌 다른 else값 닐값으로 뜬다

근데 닐값에서 다른 분기 처리를 안했을때 참과 거짓만 했을떄는 거짓으로 떨어진다?

그러지만 다른 방법으로 했는데 정말 안되는 코드를 어찌로 짜맞춘느낌? 그래도 역시나 펄스가 반환된다… 

여기서 코드의 가장 중요한 기능은 커뮤니케이션이라고 생각한다 라는 말이 나옴 가독성을 좋게 잘짜야한다.

---

### 스파게티 코드 챕터 1

- 유지보수의 어려움
- 재활용이 불가능
- 버그의 온상
- 생산성 저하

코드의 형테

- 복잡한 제어문(goto, branch, loop, Cyclomatic complexith)
    - if문이 없다면 가독성이 좋아진다 읽기편하다
- 많은 변수(단순히값을저장하는용도 ok)
    - 제어를 컨트롤 하기위한 용도 → 변수를 이용한 if, switch, for 등등.. 읽기 힘들게해버린다.
    - 제어에 사용되는 변수가 많을 수록 코드의 흐름을 따라가기 힘듦.
- 잘못된 상속
    - 상속은 가장 강한 커플링중 하나
    - 코드를 읽을 때 현재 코드와 부모클래스의 코드를 오가면서 읽어야한다…….
    - override된 함수와 아닌 함수를 구분해야한다…..  이미 어렵다 그런데 잘못된 상속이 더해진다면 문제다.
- 클래스 간 의존관계 정리가안됨
    - 클래스간 의존관계가 복잡하여 클래스를 독자적으로 재활용 할수없는상황
        - 클래스 동작을 위해서 다른 클래스 필요할때 강한참조인상황??
        - 클래스 재활용 하려고했는데 수십개의 클래스를 가져와야하는상황.??
- 추상화 단계의 부재
    - 라면 조리방법도 추상화는 잘되있다…..  상세는 추가메서드 ㅋㅋㅋㅋㅋ
    - 디테일한 설명은 없다
    - 라면 조리과정을 3단계에서 설명한다.
    - 만일 각 단계에서 세부사항을 한다면??? 물→ 생수? 수돗물? 건더기 스프 → 비닐통째? 아님 비닐뜯어서? 물의 온도는? 이런 디테일 차이?
- 기타

생기는 원인→ 게을러서, 잘몰라서
